git add .				--> Añade todas las cosas modificadas al ÍNDICE (no hace commit de nada, solo lo registra)
git add pepito.txt			--> Añade este fichero al registro ÍNDICE
git reset .				--> Quita del registro (si pones un punto quita todo, si pones el nombre de un fichero, solo ese)

git commit -m "DESCRIPCION"		--> Genera un commit, una versión, una instantanea, un tag, ...
git commit --amend -m "DESCRIPCION"	--> Corrige el commit anterior

git log					--> LOG de commits
git status				--> Información del directorio y sus ficheros respecto a GIT

git diff				--> Diferencias entre los ficheros actuales y el último commit

git mv
git rm					--> Si solo hacemos mv o rm en linux cambia el nombre en el directorio local pero no en el ÍNDICE

git checkout nombrefich			--> Descarta cambios y vuelve al último commit


git stash				--> Guarda las modificaciones actuales en una PILA

-------------8<----------------------

git push				--> Lleva del directorio local al GITHUB o nube (repositorio bare)
git clone				--> Copia repositorio
git fetch				--> Trae una rama de un repositorio de la nube o GITHUB a local, lo trae a una rama llamada origin/master, que no es tu master local, ojo.
					--> Si quieres ver esa rama oculta usa "GIT BRANCH -A"
git pull				--> Es como hacer un FETCH y, además, un MERGE --> https://es.stackoverflow.com/questions/245/cu%C3%A1l-es-la-diferencia-entre-pull-y-fetch-en-git

					Por ejemplo: git push https://github.com/kodrete/07.CFGM-SMR master

--------------------8<-----------------

git branch				--> Muestra las ramas de u repositorio. El asterisco indica donde está el puntero HEAD (ver abajo, en la parte de CHECKOUT)
- La rama MASTER se crea por defecto
- El nombre de una rama es un puntero a su último commit (el numerajo random)
- Podemos hacer commit de nuestro directorio de trabajo en cualquier rama compatible
- Para crear una rama nueva (a partir de un commit) se usa GIT BRANCH

git branch rama_nueva commit_existente	--> Crea una nueva rama a partir de un commit existente. Recuerda, un commit pertenece a una rama.

--> Cuando integras dos ramas entonces es como si tuvieras un commit nuevo que pertenece a ambas (y las fusiona)  

	rama1c1 -> rama1c2 -> rama1c3 -> (integración de rama1 en rama2)   \
	rama2c1 -> rama2c2 -> rama2c3 -> rama2c4 [...]                     -> rama1c9 (este commit esta en rama2 pero también es sucesor de rama1c3)


git show				--> Muestra los metadatos de una rama

git checkout nombre_rama/nombre_commit	--> Restaura en el directorio de trabajo lo que hubiera en ese commit (¡¡OJO!! Pierdes los cambios no guardados)
					--> HEAD siempre es un puntero al commit del directorio de trabajo, podemos consultarlo con "git show HEAD" o "git log HEAD"
					--> Es decir, para cambiar de rama usamos CHECKOUT.

git checkout -b nom_nueva_rama		--> Crea una nueva rama a partir del HEAD actual y cambia a ella en el directorio de trabajo.


git reset nom_commit			--> Lleva el puntero HEAD al commit que le digamos (ANCESTRO), sirve para "rehacer" la historia de commits. PELIGROSO.
					--> No pierdes los cambios hechos en el directorio de trabajo, solo mueves el puntero. ¿Para qué se usa entonces?
					--> Por ejemplo, retrasar el puntero que estaba en rama1c23 a rama1c20 y vuelves a hacer "ADD" y "COMMIT", has fusionado rama1c21, rama1c22 y rama1c23 en rama1c20.
					--> ¡¡¡¡¡OJO!!!!!! Si haces git reset --hard SÍ QUE PIERDES LOS CAMBIOS DEL DIRECTORIO DE TRABAJO, como si hicieras CHECKOUT del commit al que regresas.

------------------8<-----------------------

git merge c1 c2				--> Integra dos commits, aunque lo normal es indicar nombres de rama. Recuerda, el nombre de rama es un puntero al último commit de esa rama.
					--> Si genera conflictos no se hace commit, si no hay conflictos se hace autocommit. Los conflictos se ven con "GIT STATUS -S"
					--> Si vemos que hay conflictos y queremos deshacer el merge usamos "GIT MERGE --ABORT" 
					--> Los conflictos se resuelven a mano y, una vez solucionados, hacemos git commit. Podemos hacer "git commit -a" que es como hacer un "git add ." antes.
					--> ES UNA BUENA PRÁCTICA HACER UNA RAMA NUEVA PARA INTEGRAR UN MERGE, LA PODEMOS LLAMAR MERGE_DE_TAL_Y_PASCUAL (con git checkout -b merge_tal_y_tal)
					--> Por ejemplo, tenemos master Y desarrolloXX, hacemos nueva rama "merge_desarrolloX" con "git checkout -b" e integramos en ésta el MASTER con "git merge master"
					--> Ahora, querremos integrar todo lo integrado en merge_tal_y_tal en MASTER, como ya está integrado se puede hacer de manera FAST-FORWARD.
					--> FAST-FORWARD :: 1) Hacemos "git checkout master". 2) Hacemos "git merge merge_tal_y_tal" 3) GIT indicará que es un fast-forward

--------------------8<--------------------

git rebase				--> TODO ESTO se simplifica con GIT REBASE
					--> Sirve para hacer lineal una historia de commits que antes estaba en dos ramas separadas.

